# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Expectation maximization (EM) model for RNA-seq quantification.
#'
#' EM model for RNA-seq quantification. The equivalence class (ec) with 0 counts are removed, because these counts have no contributes to the final results.
#'
#' @title EM model
#' @param countraw A \code{arma::uvec} indicates the counts of ec.
#' @param maxiter The maximum iteration number with the default value of 10000.
#' @param miniter The minimum iteration number with the default value of 50.
#' @param detail A \code{bool} value.  When it is set as \code{true}, logistic likelihood and counts for each species in every iteration will be returned, otherwise \code{false}.
#' @inheritParams MatchEfflen
#' @inheritParams SplitEC
#' @inheritParams SpeCount
#' @references \href{https://arxiv.org/abs/1104.3889}{Lior Pachter: Models for transcript quantification from RNA-Seq}
#' @return A \code{List} indicates estimated counts of transcripts.
#' @examples
#' ## Single species
#' ##    f1 f2 f3
#' ## ec1 1 1 1
#' ## ec2 0 1 1
#' ## ec3 1 0 1
#' ## ec4 1 0 0
#' ## ec5 1 1 0
#' plist <- list(ec = c('0,1,2', '1,2', '0,2', '0', '0,1'), count = rep(1, 5), efflen = rep(1, 3))
#' EM(plist$efflen, plist$ec, plist$count, spenum = 3)
#'
#' ## Two species
#' ##    f1 f2 f3 f1' f2'
#' ## ec1 1  1  0  0  1
#' ## ec2 1  0  1  1  0
#' ## ec3 0  1  1  0  0
#' ## ec4 0  0  0  1  1
#' ## ec5 1  0  1  0  1
#' ## ec6 1  1  0  0  0
#' plist <- list(ec = c('0,1,4', '0,2,3', '1,2', '3,4', '0,2,4', '0,1'),
#'               count = rep(1, 6), efflen = rep(1, 5))
#' EM(plist$efflen, plist$ec, plist$count, c(3, 2))
#' ## compare with single species
#' EM(plist$efflen, plist$ec, plist$count, 5)
#' @author Yulong Niu \email{yulong.niu@@hotmail.com}
#' @export
EM <- function(efflenraw, ecraw, countraw, spenumraw, maxiter = 10000L, miniter = 50L, detail = FALSE) {
    .Call(`_RNASeqQuant_EM`, efflenraw, ecraw, countraw, spenumraw, maxiter, miniter, detail)
}

Adam <- function(efflenraw, ecraw, countraw, spenumraw, epochs = 300L, batchsize = 1000L, alpha = 0.1) {
    .Call(`_RNASeqQuant_Adam`, efflenraw, ecraw, countraw, spenumraw, epochs, batchsize, alpha)
}

Adagrad <- function(efflenraw, ecraw, countraw, spenumraw, epochs = 300L, batchsize = 1000L, alpha = 0.1) {
    .Call(`_RNASeqQuant_Adagrad`, efflenraw, ecraw, countraw, spenumraw, epochs, batchsize, alpha)
}

#' Gradient.
#'
#' \itemize{
#'   \item \code{GradientSM()}: Gradients of Softmax.
#'   \item \code{GradientSP()}: Gradients of SoftPlus.
#'   \item \code{GradientISRU()}: Gradients of ISRU.
#' }
#'
#' @title Calculate gradient
#' @return A \code{arma::vec} indicates gradients.
#' @param w A \code{arma::vec} indicates estimated parameters.
#' @param idx A \code{arma::uvec} indicates the index of \code{w} used for gradient descending.
#' @inheritParams LL
#' @author Yulong Niu \email{yulong.niu@@hotmail.com}
#' @rdname gradient
#' @keywords internal
GradientSM <- function(w, efflen, ec, count, idx) {
    .Call(`_RNASeqQuant_GradientSM`, w, efflen, ec, count, idx)
}

#' @inheritParams GradientSM
#' @rdname gradient
#' @keywords internal
GradientSP <- function(w, efflen, ec, count, idx) {
    .Call(`_RNASeqQuant_GradientSP`, w, efflen, ec, count, idx)
}

#' @inheritParams GradientSM
#' @inheritParams InvSqrtRoot
#' @rdname gradient
#' @keywords internal
GradientISRU <- function(w, efflen, ec, count, alpha, idx) {
    .Call(`_RNASeqQuant_GradientISRU`, w, efflen, ec, count, alpha, idx)
}

#' Calculate the Inverse square root unit (ISRU)
#'
#' \itemize{
#'   \item \code{InvSqrtRoot()}: Inverse square root.
#'   \item \code{ISRU()} and \code{ISRU1()}: ISRU with or without weight.
#'   \item \code{ISRUGrad()} and \code{ISRUGrad1()}: Internal functions of Partial derivation.
#' }
#'
#' @title ISRU
#' @return
#' \itemize{
#'   \item \code{InvSqrtRoot()}: A \code{arma::vec} indicates the inverse square root \eqn{\frac{1}{sqrt(1+\alpha x^2)}}.
#'   \item \code{ISRU()} and \code{ISRU1()}: A \code{arma::vec} indicates ISRU with (\eqn{(\frac{x_i}{sqrt(1+\alpha x_i^2)} + \frac{1}{\sqrt(\alpha)}) * weight_i} or without weight (\eqn{\frac{x_i}{sqrt(1+\alpha x_i^2)} + \frac{1}{\sqrt(\alpha)}}).
#'   \item \code{ISRUGrad()} and \code{ISRUGrad1()}: A \code{arma::vec} indicates \eqn{(\frac{1}{sqrt(1+\alpha x_i^2)})^3} or \eqn{(\frac{1}{sqrt(1+\alpha x_i^2)})^3 * weight_i}.
#' }
#' @param alpha \code{double}.
#' @inheritParams LogSumExp
#' @author Yulong Niu \email{yulong.niu@@hotmail.com}
#' @rdname ISRU
#' @keywords internal
InvSqrtRoot <- function(x, alpha) {
    .Call(`_RNASeqQuant_InvSqrtRoot`, x, alpha)
}

#' @param isr \code{arma::vec} indicating the inverse square root unit.
#' @inheritParams InvSqrtRoot
#' @rdname ISRU
#' @keywords internal
ISRU1 <- function(x, isr, alpha) {
    .Call(`_RNASeqQuant_ISRU1`, x, isr, alpha)
}

#' @inheritParams InvSqrtRoot
#' @inheritParams ISRU1
#' @inheritParams LogSumExp
#' @rdname ISRU
#' @keywords internal
ISRU <- function(x, isr, weight, alpha) {
    .Call(`_RNASeqQuant_ISRU`, x, isr, weight, alpha)
}

#' @inheritParams InvSqrtRoot
#' @inheritParams ISRU1
#' @rdname ISRU
#' @keywords internal
ISRUGrad1 <- function(x, isr, alpha) {
    .Call(`_RNASeqQuant_ISRUGrad1`, x, isr, alpha)
}

#' @inheritParams InvSqrtRoot
#' @inheritParams ISRU1
#' @inheritParams LogSumExp
#' @rdname ISRU
#' @keywords internal
ISRUGrad <- function(x, isr, weight, alpha) {
    .Call(`_RNASeqQuant_ISRUGrad`, x, isr, weight, alpha)
}

#' Logistic likelihood.
#'
#' The log-likelihood of given probabilities.
#'
#' @title Calculate log-likelihood
#' @return A \code{double} indicates log-likelihood.
#' @param prob A \code{arma::vec} indicates probabilities of selecting a read from the different transcripts.
#' @param efflen A \code{std::vector<arma::vec>} indicated effective length of transcripts.
#' @param ec A \code{std::vector<arma::uvec>} indicated equivalence classes (ec).
#' @param count A \code{arma::uvec} indicated counts of ec.
#' @author Yulong Niu \email{yulong.niu@@hotmail.com}
#' @keywords internal
LL <- function(prob, efflen, ec, count) {
    .Call(`_RNASeqQuant_LL`, prob, efflen, ec, count)
}

start_profiler <- function(str) {
    .Call(`_RNASeqQuant_start_profiler`, str)
}

stop_profiler <- function() {
    .Call(`_RNASeqQuant_stop_profiler`)
}

#' Calculate the log-sum-exp and softmax calculator
#'
#' \itemize{
#'   \item \code{LogSumExp()} and \code{LogSumExp1()}: log-sum-exp with or without weight.
#'   \item \code{Softmax()} and \code{Softmax1()}: Softmax with or without weight.
#' }
#'
#' @title Softmax
#' @return
#' \itemize{
#'   \item \code{LogSumExp()} and \code{LogSumExp1()}: A \code{double} indicates log-sum-exp.
#'   \item \code{Softmax()}: A \code{arma::vec} indicates the \eqn{\frac{\mathrm{e}^{x_i} * weight_i}{\sum{\mathrm{e}^{x_i} * weight_i}}}.
#'   \item \code{Softmax1()}: A \code{arma::vec} indicates the \eqn{\frac{\mathrm{e}^{x_i}}{\sum{\mathrm{e}^{x_i}}}}.
#' }
#' @param x A \code{arma::vec}.
#' @param weight A \code{arma::vec} indicating the weight.
#' @author Yulong Niu \email{yulong.niu@@hotmail.com}
#' @rdname softmax
#' @keywords internal
LogSumExp <- function(x, weight) {
    .Call(`_RNASeqQuant_LogSumExp`, x, weight)
}

#' @inheritParams LogSumExp
#' @rdname softmax
#' @keywords internal
LogSumExp1 <- function(x) {
    .Call(`_RNASeqQuant_LogSumExp1`, x)
}

#' @inheritParams LogSumExp
#' @rdname softmax
#' @keywords internal
Softmax <- function(x, weight) {
    .Call(`_RNASeqQuant_Softmax`, x, weight)
}

#' @inheritParams LogSumExp
#' @rdname softmax
#' @keywords internal
Softmax1 <- function(x) {
    .Call(`_RNASeqQuant_Softmax1`, x)
}

#' Calculate the logistic and softplus calculator
#'
#' \itemize{
#'   \item \code{Logistic()}: The logistic function.
#'   \item \item \code{Softplus()} and \code{Softplus1()}: Softplus with or without weight.
#'   \item \code{SoftplusGrad()} and \code{SoftplusGrad1()}: Internal functions for partial derivation.
#' }
#'
#' @title Softplus
#' @return
#' \itemize{
#'   \item \code{Logisitc()}: A \code{arma::vec} indicates the logistic function \eqn{\frac{1}{1 + \mathrm{e}^{-x}}}.
#'   \item \code{Softplus()} and \code{Softplus1()}: A \code{arma::vec} indicates softplus with (\eqn{\log(1 + \mathrm{e}^{x_i}) * weight_i} or without weight (\eqn{\log(1 + \mathrm{e}^{x_i})}).
#'   \item \code{SoftplusGrad()} and \code{SoftplusGrad1()}: A \code{arma::vec} indicates \eqn{\frac{logistic * weight_i}{\sum{softplus}}} or \eqn{\frac{logistic}{\sum{softplus1}}}.
#' }
#' @inheritParams LogSumExp
#' @author Yulong Niu \email{yulong.niu@@hotmail.com}
#' @rdname softplus
#' @keywords internal
Logistic <- function(x) {
    .Call(`_RNASeqQuant_Logistic`, x)
}

#' @inheritParams LogSumExp
#' @rdname softplus
#' @keywords internal
Softplus1 <- function(x) {
    .Call(`_RNASeqQuant_Softplus1`, x)
}

#' @inheritParams LogSumExp
#' @rdname softplus
#' @keywords internal
Softplus <- function(x, weight) {
    .Call(`_RNASeqQuant_Softplus`, x, weight)
}

#' @inheritParams LogSumExp
#' @rdname softplus
#' @keywords internal
SoftplusGrad1 <- function(x) {
    .Call(`_RNASeqQuant_SoftplusGrad1`, x)
}

#' @inheritParams LogSumExp
#' @rdname softplus
#' @keywords internal
SoftplusGrad <- function(x, weight) {
    .Call(`_RNASeqQuant_SoftplusGrad`, x, weight)
}

#' Split strings and equivalence classes.
#'
#' \itemize{
#'   \item \code{Strsplit()}: Split a \code{string} with an user-defined delimiter.
#'   \item \code{SplitEC()}: Split batch of equivalence classes in \code{string} format.
#' }
#'
#' @title Preprocess equivalence classes
#' @return
#' \itemize{
#'   \item \code{Strsplit()}: A \code{arma::uvec} indicating the corresponding transcripts ID (starts from 0).
#'   \item \code{SplitEC}: A \code{std::vector<arma::uvec>} and each element indicates the transcripts IDs.
#' }
#' @param s A \code{string}.
#' @param delim The delimiter
#' @references \href{https://ysonggit.github.io/coding/2014/12/16/split-a-string-using-c.html}{split string in C++}
#' @author Yulong Niu \email{yulong.niu@@hotmail.com}
#' @rdname strsplit
#' @keywords internal
Strsplit <- function(s, delim) {
    .Call(`_RNASeqQuant_Strsplit`, s, delim)
}

#' @param ecraw A \code{character vector} and each element is a string with comma delimiter.
#' @rdname strsplit
#' @keywords internal
SplitEC <- function(ecraw) {
    .Call(`_RNASeqQuant_SplitEC`, ecraw)
}

#' Match transcript effect length with equivalence classes.
#'
#' The length of \code{efflen} is equal to number of equivalence classes.
#'
#' @title Match transcript effect length
#' @return A \code{std::vector<arma::vec>} with the same length of \code{ecvec}.
#' @param ec A \code{std::vector<arma::uvec>} containing separated vectors, such as the output of \code{SplitEC()} in this package.
#' @param efflenraw A code{arma::vec} indicating the effect length of transcript.
#' @author Yulong Niu \email{yulong.niu@@hotmail.com}
#' @keywords internal
MatchEfflen <- function(ec, efflenraw) {
    .Call(`_RNASeqQuant_MatchEfflen`, ec, efflenraw)
}

#' Estimated counts of input species.
#'
#' The indices of \code{est} should be consistent with the \code{spenumraw}. For example, the \code{est} is \code{1.5, 2, 3} and \code{spenumraw} is \code{2, 1}, so \code{2.5, 3} will be returned.
#'
#' @title Species estimated counts
#' @return A \code{arma::vec} represents the total estimated counts of each species.
#' @param est A \code{arma::vec} estimated counts of each transcripts.
#' @param spenumraw A \code{arma::uvec} indicated the transcript number in each species.
#' @author Yulong Niu \email{yulong.niu@@hotmail.com}
#' @keywords internal
SpeCount <- function(est, spenumraw) {
    .Call(`_RNASeqQuant_SpeCount`, est, spenumraw)
}

