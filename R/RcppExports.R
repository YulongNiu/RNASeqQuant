# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Transform estimated count to probabilities.
#'
#' Use estimated counts as the outputs and EM stop conditions.
#'
#' @title Counts to probabilities
#' @return A \code{arma::vec} indicates probabilities of selecting a read from the different transcripts.
#' @param estcount A \code{arma::vec} estimated counts of transcripts.
#' @param spenum A \code{arma::uvec} indicated number of transcripts.
#' @author Yulong Niu \email{yulong.niu@@hotmail.com}
#' @keywords internal
Estcount2Prob <- function(estcount, spenum) {
    .Call(`_RNASeqQuant_Estcount2Prob`, estcount, spenum)
}

#' Expectation maximization (EM) model for RNA-seq quantification.
#'
#' EM model for RNA-seq quantification. The equivalence class (ec) with 0 counts are removed, because these counts have no contributes to the final results.
#'
#' @title EM model
#' @param countraw A \code{arma::uvec} indicates the counts of ec.
#' @param maxiter The maximum iteration number with the default value of 10000.
#' @param miniter The minimum iteration number with the default value of 50.
#' @inheritParams MatchEfflen
#' @inheritParams SplitEC
#' @inheritParams IdxSpenum
#' @references \href{https://arxiv.org/abs/1104.3889}{Lior Pachter: Models for transcript quantification from RNA-Seq}
#' @return A \code{numeric vector} indicates probabilities of selecting a read from the different transcripts.
#' @examples
#' ## Single species
#' ##    f1 f2 f3
#' ## ec1 1 1 1
#' ## ec2 0 1 1
#' ## ec3 1 0 1
#' ## ec4 1 0 0
#' ## ec5 1 1 0
#' plist <- list(ec = c('0,1,2', '1,2', '0,2', '0', '0,1'), count = rep(1, 5), efflen = rep(1, 3))
#' EM(plist$efflen, plist$ec, plist$count, spenum = 3)
#'
#' ## Two species
#' ##    f1 f2 f3 f1' f2'
#' ## ec1 1  1  0  0  1
#' ## ec2 1  0  1  1  0
#' ## ec3 0  1  1  0  0
#' ## ec4 0  0  0  1  1
#' ## ec5 1  0  1  0  1
#' ## ec6 1  1  0  0  0
#' plist <- list(ec = c('0,1,4', '0,2,3', '1,2', '3,4', '0,2,4', '0,1'),
#'               count = rep(1, 6), efflen = rep(1, 5))
#' EM(plist$efflen, plist$ec, plist$count, c(3, 2))
#' ## compare with single species
#' EM(plist$efflen, plist$ec, plist$count, 5)
#' @author Yulong Niu \email{yulong.niu@@hotmail.com}
#' @export
EM <- function(efflenraw, ecraw, countraw, spenumraw, maxiter = 10000L, miniter = 50L) {
    .Call(`_RNASeqQuant_EM`, efflenraw, ecraw, countraw, spenumraw, maxiter, miniter)
}

Adam <- function(efflenraw, ecraw, countraw, spenumraw, epochs = 300L, batchsize = 1000L, alpha = 0.01) {
    .Call(`_RNASeqQuant_Adam`, efflenraw, ecraw, countraw, spenumraw, epochs, batchsize, alpha)
}

GradientSM <- function(w, efflen, ec, count, spenum, idx) {
    .Call(`_RNASeqQuant_GradientSM`, w, efflen, ec, count, spenum, idx)
}

GradientISRU <- function(w, efflen, ec, count, spenum, alpha, idx) {
    .Call(`_RNASeqQuant_GradientISRU`, w, efflen, ec, count, spenum, alpha, idx)
}

GradientSP <- function(w, efflen, ec, count, idx) {
    .Call(`_RNASeqQuant_GradientSP`, w, efflen, ec, count, idx)
}

InvSqrtRoot <- function(x, alpha) {
    .Call(`_RNASeqQuant_InvSqrtRoot`, x, alpha)
}

ISRU1 <- function(x, isr, alpha) {
    .Call(`_RNASeqQuant_ISRU1`, x, isr, alpha)
}

ISRU <- function(x, isr, weight, alpha) {
    .Call(`_RNASeqQuant_ISRU`, x, isr, weight, alpha)
}

ISRUGrad1 <- function(x, isr, alpha) {
    .Call(`_RNASeqQuant_ISRUGrad1`, x, isr, alpha)
}

ISRUGrad <- function(x, isr, weight, alpha) {
    .Call(`_RNASeqQuant_ISRUGrad`, x, isr, weight, alpha)
}

SingleSpeGradISRU <- function(wlse, efflensg, ecd, ecsum, ecratio, idx) {
    .Call(`_RNASeqQuant_SingleSpeGradISRU`, wlse, efflensg, ecd, ecsum, ecratio, idx)
}

ECGradISRU <- function(w, wlse, efflensg, wsg, alpha) {
    .Call(`_RNASeqQuant_ECGradISRU`, w, wlse, efflensg, wsg, alpha)
}

#' Logistic likelihood.
#'
#' The log-likelihood of given probabilities.
#'
#' @title Calculate log-likelihood
#' @return A \code{double} indicates log-likelihood.
#' @param prob A \code{arma::vec} indicates probabilities of selecting a read from the different transcripts.
#' @param efflen A \code{std::vector<arma::vec>} indicated effective length of transcripts.
#' @param ec A \code{std::vector<arma::uvec>} indicated equivalence classes (ec).
#' @param count A \code{arma::uvec} indicated counts of ec.
#' @author Yulong Niu \email{yulong.niu@@hotmail.com}
#' @keywords internal
LLEM <- function(prob, efflen, ec, count) {
    .Call(`_RNASeqQuant_LLEM`, prob, efflen, ec, count)
}

LLGD <- function(prob, efflen, ec, count) {
    .Call(`_RNASeqQuant_LLGD`, prob, efflen, ec, count)
}

start_profiler <- function(str) {
    .Call(`_RNASeqQuant_start_profiler`, str)
}

stop_profiler <- function() {
    .Call(`_RNASeqQuant_stop_profiler`)
}

#' Calculate the log-sum-exp and softmax calculator
#'
#' \itemize{
#'   \item \code{LogSumExp()}: Weighted log-sum-exp.
#'   \item \code{LogSumExp1()}: log-sum-exp without weight.
#'   \item \code{Softmax()}: Numerator is the exponent of every element of input \code{x}, and denominator is the sum of \code{exp(x)}.
#'   \item \code{Softmax1()}: \code{weight} is 1.
#' }
#'
#' @title Softmax
#' @return
#' \itemize{
#'   \item \code{LogSumExp()} and \code{LogSumExp1()}: A \code{double} indicates log-sum-exp.
#'   \item \code{Softmax()}: A \code{arma::vec} indicates the \eqn{\frac{\mathrm{e}^{x_i} * weight_i}{\sum{\mathrm{e}^{x_i} * weight_i}}}.
#'   \item \code{Softmax1()}: A \code{arma::vec} indicates the \eqn{\frac{\mathrm{e}^{x_i}}{\sum{\mathrm{e}^{x_i}}}}.
#' }
#' @param x A \code{arma::vec}.
#' @param weight A \code{arma::vec} indicating the weight.
#' @author Yulong Niu \email{yulong.niu@@hotmail.com}
#' @rdname softmax
#' @keywords internal
LogSumExp <- function(x, weight) {
    .Call(`_RNASeqQuant_LogSumExp`, x, weight)
}

#' @inheritParams LogSumExp
#' @rdname softmax
#' @keywords internal
LogSumExp1 <- function(x) {
    .Call(`_RNASeqQuant_LogSumExp1`, x)
}

#' @inheritParams LogSumExp
#' @rdname softmax
#' @keywords internal
Softmax <- function(x, weight) {
    .Call(`_RNASeqQuant_Softmax`, x, weight)
}

#' @inheritParams LogSumExp
#' @rdname softmax
#' @keywords internal
Softmax1 <- function(x) {
    .Call(`_RNASeqQuant_Softmax1`, x)
}

SingleSpeGradSM <- function(w, efflensg, wsg, ecratio, idx) {
    .Call(`_RNASeqQuant_SingleSpeGradSM`, w, efflensg, wsg, ecratio, idx)
}

ECGradSM <- function(w, wlse, efflensg, wsg) {
    .Call(`_RNASeqQuant_ECGradSM`, w, wlse, efflensg, wsg)
}

#' Calculate the logistic and softplus calculator
#'
#' \itemize{
#'   \item \code{Logistic()}: The logistic function.
#'   \item \item \code{Softplus()} and \code{Softplus1()}: The softplus function.
#'   \item \code{SoftplusGrad()} and \code{SoftplusGrad1()}: Internal functions for partial derivation.
#' }
#'
#' @title Softplus
#' @return
#' \itemize{
#'   \item \code{Logisitc()}: A \code{arma::vec} indicates the logistic function \eqn{\frac{1}{1 + \mathrm{e}^{-x}}}.
#'   \item \code{Softplus()} and \code{Softplus1()}: A \code{arma::vec} indicates softplus with (\eqn{\log(1 + \mathrm{e}^{x_i}) * weight_i} or without weight (\eqn{\log(1 + \mathrm{e}^{x_i})}).
#'   \item \code{SoftplusGrad()} and \code{SoftplusGrad1()}: A \code{arma::vec} indicates \eqn{\frac{logistic * weight_i}{\sum{softplus}}} or \eqn{\frac{logistic}{\sum{softplus1}}}.
#' }
#' @inheritParams LogSumExp
#' @author Yulong Niu \email{yulong.niu@@hotmail.com}
#' @rdname softplus
#' @keywords internal
Logistic <- function(x) {
    .Call(`_RNASeqQuant_Logistic`, x)
}

#' @inheritParams LogSumExp
#' @rdname softplus
#' @keywords internal
Softplus1 <- function(x) {
    .Call(`_RNASeqQuant_Softplus1`, x)
}

#' @inheritParams LogSumExp
#' @rdname softplus
#' @keywords internal
Softplus <- function(x, weight) {
    .Call(`_RNASeqQuant_Softplus`, x, weight)
}

#' @inheritParams LogSumExp
#' @rdname softplus
#' @keywords internal
SoftplusGrad1 <- function(x) {
    .Call(`_RNASeqQuant_SoftplusGrad1`, x)
}

#' @inheritParams LogSumExp
#' @rdname softplus
#' @keywords internal
SoftplusGrad <- function(x, weight) {
    .Call(`_RNASeqQuant_SoftplusGrad`, x, weight)
}

GradientSMSS <- function(w, efflen, ec, count, idx) {
    .Call(`_RNASeqQuant_GradientSMSS`, w, efflen, ec, count, idx)
}

TestGradientSM <- function(ecraw, efflenraw, spenum, w, count, idx) {
    .Call(`_RNASeqQuant_TestGradientSM`, ecraw, efflenraw, spenum, w, count, idx)
}

GradientISRUSS <- function(w, efflen, ec, count, alpha, idx) {
    .Call(`_RNASeqQuant_GradientISRUSS`, w, efflen, ec, count, alpha, idx)
}

TestGradientISRU <- function(ecraw, efflenraw, spenum, w, count, alpha, idx) {
    .Call(`_RNASeqQuant_TestGradientISRU`, ecraw, efflenraw, spenum, w, count, alpha, idx)
}

#' Split strings and equivalence classes.
#'
#' \itemize{
#'   \item \code{Strsplit()}: Split a \code{string} with an user-defined delimiter.
#'   \item \code{SplitEC()}: Split batch of equivalence classes in \code{string} format.
#' }
#'
#' @title Preprocess equivalence classes
#' @return
#' \itemize{
#'   \item \code{Strsplit()}: A \code{arma::uvec} indicating the corresponding transcripts ID (starts from 0).
#'   \item \code{SplitEC}: A \code{std::vector<arma::uvec>} and each element indicates the transcripts IDs.
#' }
#' @param s A \code{string}.
#' @param delim The delimiter
#' @references \href{https://ysonggit.github.io/coding/2014/12/16/split-a-string-using-c.html}{split string in C++}
#' @author Yulong Niu \email{yulong.niu@@hotmail.com}
#' @rdname strsplit
#' @keywords internal
Strsplit <- function(s, delim) {
    .Call(`_RNASeqQuant_Strsplit`, s, delim)
}

#' @param ecraw A \code{character vector} and each element is a string with comma delimiter.
#' @rdname strsplit
#' @keywords internal
SplitEC <- function(ecraw) {
    .Call(`_RNASeqQuant_SplitEC`, ecraw)
}

#' Match transcript effect length with equivalence classes.
#'
#' The length of \code{efflen} is equal to number of transcripts.
#'
#' @title Match transcript effect length
#' @return A \code{std::vector<arma::vec>} with the same length of \code{ecvec}.
#' @param ec A \code{std::vector<arma::uvec>} containing separated vectors, such as the output of \code{SplitEC()} in this package.
#' @param efflenraw A code{arma::vec} indicating the effect length of transcript.
#' @author Yulong Niu \email{yulong.niu@@hotmail.com}
#' @keywords internal
MatchEfflen <- function(ec, efflenraw) {
    .Call(`_RNASeqQuant_MatchEfflen`, ec, efflenraw)
}

#' Index transcripts number of input species.
#'
#' Add zero at the head of input \code{spenum}.
#'
#' @title Index species number
#' @return A \code{arma::uvec}.
#' @param spenumraw A \code{arma::uvec} indicated the transcript number in each species.
#' @author Yulong Niu \email{yulong.niu@@hotmail.com}
#' @keywords internal
IdxSpenum <- function(spenumraw) {
    .Call(`_RNASeqQuant_IdxSpenum`, spenumraw)
}

EC2SpeSg <- function(ecsg, efflensg, ecsgraw, efflenraw, spenum) {
    invisible(.Call(`_RNASeqQuant_EC2SpeSg`, ecsg, efflensg, ecsgraw, efflenraw, spenum))
}

EC2Spe <- function(ec, efflen, ecraw, efflenraw, spenum) {
    invisible(.Call(`_RNASeqQuant_EC2Spe`, ec, efflen, ecraw, efflenraw, spenum))
}

CmpUvec <- function(x) {
    .Call(`_RNASeqQuant_CmpUvec`, x)
}

CmpVec <- function(x) {
    .Call(`_RNASeqQuant_CmpVec`, x)
}

