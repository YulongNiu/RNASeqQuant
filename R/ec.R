##' Read in equivalence class
##'
##' Read in equivalence class file generated from \code{kallisto} (version 0.44.0). The \code{*.ec} file can be generated by the \code{pseudo} command in the \code{kallisto}.
##'
##' @title Standard read in ec files
##' @param ecpath The path of ec files.
##' @return A \code{list}. 1st element is ec, and 2nd element is transcript ID.
##' @examples
##' require('magrittr')
##'
##' ec <- system.file('extdata', 'example.ec', package = 'RNASeqEM') %>% read_ec
##' @author Yulong Niu \email{yulong.niu@@hotmail.com}
##' @importFrom utils read.table
##' @export
##'
read_ec <- function(ecpath) {

  ecMat <- read.table(ecpath, stringsAsFactors = FALSE)

  ecList <- list(ecs = ecMat[, 1],
                 ts = strsplit(ecMat[, 2], split = ',', fixed = TRUE))

  return(ecList)
}

##' Find equivalence class clusters
##'
##' Cluster ec with common transcripts.
##'
##' @title Cluster equivalence class
##' @param ec A \code{list} of equivalence class
##' @return A \code{list}. Each element is an ec cluster.
##' @examples
##' require('magrittr')
##'
##' ec <- system.file('extdata', 'example.ec', package = 'RNASeqEM') %>% read_ec
##' Clusterec(ec)
##' @author Yulong Niu \email{yulong.niu@@hotmail.com}
##' @importFrom magrittr %<>% %>%
##' @export
##'
Clusterec <- function(ec) {

  eccluster <- list()

  ## search seed
  ec1st <- ec$ecs[1]
  t1st <- ec$ts[[1]]

  ## search space
  ecs <- ec$ecs[-1]
  ts <- ec$ts[-1]

  while(TRUE) {

    ## break point
    if (length(ecs) == 0) {
      break
    } else {}

    ## check common t
    eachlog <- sapply(ts, function(x) {
      return(sum(t1st %in% x) > 0)
    })

    ## update ecs and ts
    if (sum(eachlog) > 0) {
      ec1st %<>% c(ecs[eachlog])
      t1st <- ts %>% collapseL_(eachlog) %>% c(t1st) %>% unique
      ecs %<>% `[`(!eachlog)
      ts %<>% `[`(!eachlog)
    } else {
      eccluster[[length(eccluster) + 1]] <- list(ec = ec1st, t = t1st)
      ec1st <- ecs[1]
      t1st <- ts[[1]]
      ecs %<>% `[`(-1)
      ts %<>% `[`(-1)
    }
  }

  return(eccluster)
}


##' Cluster EM internal functions.
##'
##' Collapse list.
##'
##' @title Internal functions for cluster EM
##' @param l A \code{list}. Each element is a vector.
##' @return A \code{list}.
##' @author Yulong Niu \email{yulong.niu@@hotmail.com}
##' @importFrom magrittr %>%
##' @keywords internal
##'
collapseL_ <- function(l, logidx) {
  res <- l[logidx] %>% unlist
  return(res)
}



## library('Rcpp')
## sourceCpp('../src/utilities.cpp')
## sourceCpp('../src/EM.cpp')

## ##    f1 f2 f3
## ## ec1 1 1 1
## ## ec2 0 1 1
## ## ec3 1 0 1
## ## ec4 1 0 0
## ## ec5 1 1 0

## cp <- rep(1/3, 3)
## cp <- c(1/6, 1/3, 1/2)
## ec <- SplitEC(c('0,1,2', '1,2', '0,2', '0', '0,1'))
## effectlen <- MatchEfflen(ec, rep(1, 3))
## ecnum <- rep(1, 5)
## spenum <- IdxSpenum(3)

## for (i in 1:100000) {
##   cp <- EMSingle(cp, effectlen, ec, ecnum, spenum)
## }

## cp

## ##    f1 f2 f3 f1' f2'
## ## ec1 1  1  0  0  1
## ## ec2 1  0  1  1  0
## ## ec3 0  1  1  0  0
## ## ec4 0  0  0  1  1
## ## ec5 1  0  1  0  1
## ## ec6 1  1  0  0  0

## cp <- c(rep(1/3, 3), rep(1/2, 2))

## cp <- c(c(1/6, 1/2, 1/3), rep(1/2, 2))

## cp <- c(c(1/6, 1/2, 1/3), c(1/4, 3/4))

## effectlen <- list(rep(1, 3), rep(1, 3), rep(1, 2), rep(1, 2), rep(1, 3), rep(1, 2))
## ec <- SplitEC(c('0,1,4', '0,2,3', '1,2', '3,4', '0,2,4', '0,1'))
## effectlen <- MatchEfflen(ec, rep(1, 5))
## ecnum <- rep(1, 6)
## spenum <- IdxSpenum(c(3, 2))

## for (i in 1:100000) {
##   cp <- EMSingle(cp, effectlen, ec, ecnum, spenum)
## }

## cp


## ## test simulate exampl
## library('magrittr')
## setwd('/extDisk1/RESEARCH/RNASeqEMtest/ktest/testpseudo/')
## ec <- read.delim('pseudoalignments.ec',
##                  stringsAsFactor = FALSE,
##                  header = FALSE)[, 2] %>%
##   SplitEC

## effectlen <- read.delim('../testquant/abundance.tsv',
##                         stringsAsFactor = FALSE)[, 3] %>%
##   MatchEfflen(ec, .)

## ecnum <- read.delim('pseudoalignments.tsv',
##                     stringsAsFactor = FALSE,
##                     header = FALSE)[, 2]

## tsnum <- unlist(ec) %>% max %>% `+`(1)
## spenum <- IdxSpenum(tsnum)

## cp <- rep(1/tsnum, tsnum)

## for (i in 1:52) {
##   cp <- EMSingle(cp, effectlen, ec, ecnum, spenum)
## }

## cp * 9413
